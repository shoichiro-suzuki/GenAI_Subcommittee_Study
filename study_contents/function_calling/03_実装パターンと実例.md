# 3. 実装パターンと実例

## 3.1 データベースサーチの実装

### ユースケース
自然言語クエリをSQLに変換し、データベースから情報を取得

**例**：「2024年1月の売上が100万円以上の商品を教えて」

### ツール定義例

```python
tools = [{
    "type": "function",
    "function": {
        "name": "search_products",
        "description": "商品データベースを検索する。売上、日付、カテゴリなどの条件で検索可能。",
        "parameters": {
            "type": "object",
            "properties": {
                "start_date": {
                    "type": "string",
                    "description": "検索開始日（YYYY-MM-DD形式）"
                },
                "end_date": {
                    "type": "string",
                    "description": "検索終了日（YYYY-MM-DD形式）"
                },
                "min_sales": {
                    "type": "number",
                    "description": "最低売上金額"
                },
                "category": {
                    "type": "string",
                    "description": "商品カテゴリ"
                }
            },
            "required": []
        }
    }
}]
```

### パラメータ設計のポイント
- **柔軟な検索条件**：required を空にして、任意の条件で検索可能に
- **明確な形式指定**：日付フォーマットを description で明示
- **具体的な説明**：「売上、日付、カテゴリなどの条件で検索可能」と用途を明記

### 実装例

```python
import openai
import sqlite3
import json

def search_products(start_date=None, end_date=None, min_sales=None, category=None):
    """商品データベースを検索"""
    conn = sqlite3.connect('products.db')
    cursor = conn.cursor()

    # 動的にSQLを構築
    query = "SELECT product_name, sales_amount, sale_date, category FROM products WHERE 1=1"
    params = []

    if start_date:
        query += " AND sale_date >= ?"
        params.append(start_date)
    if end_date:
        query += " AND sale_date <= ?"
        params.append(end_date)
    if min_sales:
        query += " AND sales_amount >= ?"
        params.append(min_sales)
    if category:
        query += " AND category = ?"
        params.append(category)

    cursor.execute(query, params)
    results = cursor.fetchall()
    conn.close()

    # 結果を辞書形式に変換
    products = []
    for row in results:
        products.append({
            "product_name": row[0],
            "sales_amount": row[1],
            "sale_date": row[2],
            "category": row[3]
        })

    return products

# OpenAI API呼び出し
messages = [
    {"role": "user", "content": "2024年1月の売上が100万円以上の商品を教えて"}
]

response = openai.ChatCompletion.create(
    model="gpt-5.1-instant",
    messages=messages,
    tools=tools
)

# 関数呼び出しの処理
if response.choices[0].finish_reason == "tool_calls":
    tool_call = response.choices[0].message.tool_calls[0]
    function_name = tool_call.function.name
    arguments = json.loads(tool_call.function.arguments)

    # 関数実行
    if function_name == "search_products":
        result = search_products(**arguments)

        # 結果をフィードバック
        messages.append(response.choices[0].message)
        messages.append({
            "role": "tool",
            "tool_call_id": tool_call.id,
            "name": function_name,
            "content": json.dumps(result, ensure_ascii=False)
        })

        # 最終レスポンス取得
        final_response = openai.ChatCompletion.create(
            model="gpt-5.1-instant",
            messages=messages
        )

        print(final_response.choices[0].message.content)
```

### 疑似的なやり取り（IN/OUTサンプル）

#### ステップ1: ユーザープロンプト → LLM

**INPUT（ユーザー）**:
```json
{
  "role": "user",
  "content": "2024年1月の売上が100万円以上の商品を教えて"
}
```

#### ステップ2: LLM → 関数呼び出し指示

**OUTPUT（LLM）**:
```json
{
  "role": "assistant",
  "content": null,
  "tool_calls": [{
    "id": "call_abc123",
    "type": "function",
    "function": {
      "name": "search_products",
      "arguments": "{\"start_date\": \"2024-01-01\", \"end_date\": \"2024-01-31\", \"min_sales\": 1000000}"
    }
  }],
  "finish_reason": "tool_calls"
}
```

**解説**: LLMが自然言語から以下を抽出
- `start_date`: "2024-01-01"（2024年1月の開始日）
- `end_date`: "2024-01-31"（2024年1月の終了日）
- `min_sales`: 1000000（100万円）

#### ステップ3: クライアント → 関数実行

**INPUT（関数に渡される引数）**:
```python
{
  "start_date": "2024-01-01",
  "end_date": "2024-01-31",
  "min_sales": 1000000
}
```

**実行されるSQL**:
```sql
SELECT product_name, sales_amount, sale_date, category
FROM products
WHERE 1=1
  AND sale_date >= '2024-01-01'
  AND sale_date <= '2024-01-31'
  AND sales_amount >= 1000000
```

**OUTPUT（関数実行結果）**:
```json
[
  {
    "product_name": "ノートPC Pro X1",
    "sales_amount": 1500000,
    "sale_date": "2024-01-15",
    "category": "電子機器"
  },
  {
    "product_name": "デスク用モニター 4K",
    "sales_amount": 1200000,
    "sale_date": "2024-01-20",
    "category": "電子機器"
  }
]
```

#### ステップ4: クライアント → LLMへ結果フィードバック

**INPUT（LLMへのフィードバック）**:
```json
{
  "role": "tool",
  "tool_call_id": "call_abc123",
  "name": "search_products",
  "content": "[{\"product_name\": \"ノートPC Pro X1\", \"sales_amount\": 1500000, \"sale_date\": \"2024-01-15\", \"category\": \"電子機器\"}, {\"product_name\": \"デスク用モニター 4K\", \"sales_amount\": 1200000, \"sale_date\": \"2024-01-20\", \"category\": \"電子機器\"}]"
}
```

#### ステップ5: LLM → 最終レスポンス

**OUTPUT（最終回答）**:
```json
{
  "role": "assistant",
  "content": "2024年1月の売上が100万円以上の商品は2件見つかりました：\n\n1. ノートPC Pro X1（電子機器）\n   - 売上: 150万円\n   - 日付: 2024年1月15日\n\n2. デスク用モニター 4K（電子機器）\n   - 売上: 120万円\n   - 日付: 2024年1月20日",
  "finish_reason": "stop"
}
```

## 3.2 機械的な処理の実装

### ユースケース
データ変換・計算処理の自動実行

**例**：「この請求書から必要な情報を抽出して」

### ツール定義例：構造化データ抽出

```python
tools = [{
    "type": "function",
    "function": {
        "name": "extract_invoice_data",
        "description": "請求書テキストから構造化データを抽出する",
        "parameters": {
            "type": "object",
            "properties": {
                "invoice_number": {
                    "type": "string",
                    "description": "請求書番号"
                },
                "issue_date": {
                    "type": "string",
                    "description": "発行日（YYYY-MM-DD形式）"
                },
                "amount": {
                    "type": "number",
                    "description": "請求金額"
                },
                "company_name": {
                    "type": "string",
                    "description": "会社名"
                },
                "items": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "name": {"type": "string"},
                            "quantity": {"type": "number"},
                            "unit_price": {"type": "number"}
                        }
                    },
                    "description": "請求項目リスト"
                }
            },
            "required": ["invoice_number", "amount"]
        }
    }
}]
```

### 実装例

```python
def extract_invoice_data(**kwargs):
    """請求書データ抽出（LLMが構造化した結果を受け取り、保存する）"""
    # Function Callingでは、LLMが既に構造化済み
    # この関数は検証・保存のみ行う

    # データベース保存（疑似コード）
    # save_to_database(kwargs)

    return {"status": "success", "data": kwargs}

# 使用例
response = openai.ChatCompletion.create(
    model="gpt-5.1-instant",
    messages=[{
        "role": "user",
        "content": """
        以下の請求書から情報を抽出してください：

        請求書番号: INV-2024-001
        発行日: 2024年1月15日
        株式会社サンプル 御中

        品目: ノートPC x 2台 @150,000円
        品目: モニター x 3台 @30,000円

        合計: 390,000円
        """
    }],
    tools=tools,
    tool_choice={"type": "function", "function": {"name": "extract_invoice_data"}}
)
```

### 疑似的なやり取り（IN/OUTサンプル）

#### ステップ1: ユーザープロンプト → LLM

**INPUT（ユーザー）**:
```json
{
  "role": "user",
  "content": "以下の請求書から情報を抽出してください：\n\n請求書番号: INV-2024-001\n発行日: 2024年1月15日\n株式会社サンプル 御中\n\n品目: ノートPC x 2台 @150,000円\n品目: モニター x 3台 @30,000円\n\n合計: 390,000円"
}
```

#### ステップ2: LLM → 関数呼び出し指示（構造化データ生成）

**OUTPUT（LLM）**:
```json
{
  "role": "assistant",
  "content": null,
  "tool_calls": [{
    "id": "call_xyz456",
    "type": "function",
    "function": {
      "name": "extract_invoice_data",
      "arguments": "{\"invoice_number\": \"INV-2024-001\", \"issue_date\": \"2024-01-15\", \"amount\": 390000, \"company_name\": \"株式会社サンプル\", \"items\": [{\"name\": \"ノートPC\", \"quantity\": 2, \"unit_price\": 150000}, {\"name\": \"モニター\", \"quantity\": 3, \"unit_price\": 30000}]}"
    }
  }],
  "finish_reason": "tool_calls"
}
```

**解説**: LLMが非構造化テキストから以下を抽出・構造化
- `invoice_number`: "INV-2024-001"
- `issue_date`: "2024-01-15"（自動的にYYYY-MM-DD形式に変換）
- `amount`: 390000
- `company_name`: "株式会社サンプル"
- `items`: 配列形式で2つの品目を抽出

#### ステップ3: クライアント → 関数実行

**INPUT（関数に渡される引数）**:
```python
{
  "invoice_number": "INV-2024-001",
  "issue_date": "2024-01-15",
  "amount": 390000,
  "company_name": "株式会社サンプル",
  "items": [
    {"name": "ノートPC", "quantity": 2, "unit_price": 150000},
    {"name": "モニター", "quantity": 3, "unit_price": 30000}
  ]
}
```

**OUTPUT（関数実行結果）**:
```json
{
  "status": "success",
  "data": {
    "invoice_number": "INV-2024-001",
    "issue_date": "2024-01-15",
    "amount": 390000,
    "company_name": "株式会社サンプル",
    "items": [
      {"name": "ノートPC", "quantity": 2, "unit_price": 150000},
      {"name": "モニター", "quantity": 3, "unit_price": 30000}
    ]
  }
}
```

#### ステップ4: クライアント → LLMへ結果フィードバック

**INPUT（LLMへのフィードバック）**:
```json
{
  "role": "tool",
  "tool_call_id": "call_xyz456",
  "name": "extract_invoice_data",
  "content": "{\"status\": \"success\", \"data\": {\"invoice_number\": \"INV-2024-001\", \"issue_date\": \"2024-01-15\", \"amount\": 390000, \"company_name\": \"株式会社サンプル\", \"items\": [{\"name\": \"ノートPC\", \"quantity\": 2, \"unit_price\": 150000}, {\"name\": \"モニター\", \"quantity\": 3, \"unit_price\": 30000}]}}"
}
```

#### ステップ5: LLM → 最終レスポンス

**OUTPUT（最終回答）**:
```json
{
  "role": "assistant",
  "content": "請求書から以下の情報を抽出し、データベースに保存しました：\n\n- 請求書番号: INV-2024-001\n- 発行日: 2024年1月15日\n- 請求先: 株式会社サンプル\n- 請求金額: 390,000円\n\n品目明細:\n1. ノートPC: 2台 × 150,000円 = 300,000円\n2. モニター: 3台 × 30,000円 = 90,000円",
  "finish_reason": "stop"
}
```

### enum活用による安定出力

**ツール定義例**:
```python
tools = [{
    "type": "function",
    "function": {
        "name": "classify_category",
        "description": "テキストを指定されたカテゴリに分類する",
        "parameters": {
            "type": "object",
            "properties": {
                "text": {
                    "type": "string",
                    "description": "分類対象のテキスト"
                },
                "category": {
                    "type": "string",
                    "enum": ["技術", "ビジネス", "エンターテイメント", "スポーツ", "その他"],
                    "description": "分類カテゴリ"
                }
            },
            "required": ["text", "category"]
        }
    }
}]
```

**enumのメリット**：
- LLMが定義されたカテゴリのみを返す
- 想定外の値を防ぐ
- 後続処理が安定する

---

## 参考情報

### データベース検索
- [ChatGPT Function Callingとベクトル検索の組み合わせ - Qiita](https://qiita.com/kuromiya123/items/35f7dc522ecd988015b6)
  - ベクトルDB + Function Callingの実例

- [ChatGPTのFunction callingで複数機能を実装](https://sinyblog.com/python/chatgpt-function-calling/)
  - SQLiteDBを使った実装例

### 構造化データ抽出
- [ChatGPT APIのFunction callingを使って、請求書の構造化データを抽出する - gihyo.jp](https://gihyo.jp/article/2023/07/programming-with-chatgpt-04)
  - 請求書からのデータ抽出実例

- [ChatGPT API + Function Callingで学習データ不要のカテゴリ推定 - Qiita](https://qiita.com/muraokaz/items/602fc300699e6aed4965)
  - enumを活用した分類処理

### 実装パターン
- [ChatGPT APIのFunction callingを使って頑張らずにチャットをアクションに繋げる - Qiita](https://qiita.com/ysv/items/cbdbb994dac790e26489)
  - アクション連携の実装パターン

- [ChatGPT最新機能 Function CallingでQiitaへの理解が深いLINE Botを作る - Qiita](https://qiita.com/watanabe-tsubasa/items/d3cc36ebf41ae81da530)
  - 外部API連携の実例
