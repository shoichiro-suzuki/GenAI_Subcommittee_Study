# 4. ベストプラクティス

## 4.1 ツール設計

### 明確な関数名と説明

**悪い例**：
```python
{
    "name": "search",
    "description": "検索する"
}
```

**良い例**：
```python
{
    "name": "search_products_by_criteria",
    "description": "商品データベースを条件で検索する。売上金額、日付範囲、カテゴリなどの条件を指定可能。"
}
```

**ポイント**：
- 関数名は具体的に（`search` → `search_products_by_criteria`）
- 説明文で「何ができるか」を明記
- 利用可能な条件を列挙

### 適切な粒度

**粒度が細かすぎる例**（非推奨）：
```python
tools = [
    {"function": {"name": "get_product_name"}},
    {"function": {"name": "get_product_price"}},
    {"function": {"name": "get_product_stock"}},
]
```

**適切な粒度**（推奨）：
```python
tools = [
    {
        "function": {
            "name": "get_product_info",
            "description": "商品情報を取得する（名前、価格、在庫を含む）"
        }
    }
]
```

**ポイント**：
- 関連する情報は1つの関数にまとめる
- 複数回のAPI呼び出しを避ける
- ただし、責務は明確に分離

### エラーメッセージの設計

**実装例**：
```python
def search_products(**kwargs):
    try:
        # 処理実行
        results = execute_search(**kwargs)
        return {
            "status": "success",
            "data": results,
            "count": len(results)
        }
    except ValueError as e:
        return {
            "status": "error",
            "error_type": "validation_error",
            "message": f"入力値が不正です: {str(e)}",
            "suggestion": "日付はYYYY-MM-DD形式で指定してください"
        }
    except Exception as e:
        return {
            "status": "error",
            "error_type": "system_error",
            "message": f"エラーが発生しました: {str(e)}"
        }
```

**ポイント**：
- 構造化されたエラーレスポンス
- エラータイプを明示
- ユーザーへの改善案を含める

## 4.2 セキュリティ

Function callingでは、LLMが生成したパラメータがそのまま実行されるため、適切なセキュリティ対策が不可欠です。

### SQLインジェクション対策

#### セキュリティリスク

**攻撃シナリオ**：
悪意のあるユーザーが、LLMに不正なSQL構文を含むプロンプトを送信

**例**：
```
ユーザープロンプト: "カテゴリが「'; DROP TABLE products; --」の商品を検索して"
```

**脆弱なコード**：
```python
def search_products(category):
    # 直接文字列結合 - 危険！
    query = f"SELECT * FROM products WHERE category = '{category}'"
    cursor.execute(query)
```

**実行されるSQL**（破壊的）：
```sql
SELECT * FROM products WHERE category = ''; DROP TABLE products; --'
```

**結果**: `products`テーブルが削除される

#### 対策1: プレースホルダの使用

```python
def search_products(category):
    # プレースホルダを使用 - 安全
    query = "SELECT * FROM products WHERE category = ?"
    cursor.execute(query, (category,))
```

**なぜ安全か**：
- SQLパーサーがパラメータ値とSQL構文を明確に分離
- パラメータ値は文字列リテラルとして扱われる
- 特殊文字が自動的にエスケープされる

**実行されるSQL**（安全）：
```sql
SELECT * FROM products WHERE category = '''; DROP TABLE products; --'
```
※ 全体が1つの文字列として扱われ、テーブル削除は実行されない

#### 対策2: ORMの使用

```python
from sqlalchemy import select

def search_products(category):
    # ORMを使用 - 最も安全
    stmt = select(Product).where(Product.category == category)
    results = session.execute(stmt)
```

**メリット**：
- SQL構文を直接書かない
- フレームワークが自動的にエスケープ
- タイプセーフ

### 入力検証

#### セキュリティリスク

**リスク1: 異常値による処理エラー**
```python
# 負の金額で検索→予期しない結果
{"min_sales": -1000000}

# 不正な日付形式→例外発生
{"date": "2024/13/45"}

# 過度に長い文字列→メモリ消費、DoS
{"text": "A" * 10000000}
```

**リスク2: データベース負荷**
```python
# 上限なしの検索→全件取得でメモリ枯渇
{"limit": 999999999}
```

#### 対策: 包括的な入力検証

```python
import re
from datetime import datetime

def validate_input(params):
    """入力パラメータの検証"""

    # 日付形式の検証
    if 'date' in params:
        try:
            datetime.strptime(params['date'], '%Y-%m-%d')
        except ValueError:
            raise ValueError("日付はYYYY-MM-DD形式で指定してください")

    # 数値範囲の検証
    if 'amount' in params:
        if not isinstance(params['amount'], (int, float)):
            raise ValueError("金額は数値で指定してください")
        if params['amount'] < 0:
            raise ValueError("金額は0以上である必要があります")
        if params['amount'] > 1000000000:  # 上限設定
            raise ValueError("金額は10億円以下で指定してください")

    # 文字列長の制限
    if 'text' in params:
        if len(params['text']) > 10000:
            raise ValueError("テキストは10000文字以内で指定してください")

    # 検索件数の上限
    if 'limit' in params:
        if params['limit'] > 1000:
            params['limit'] = 1000  # 強制的に上限を適用

    return True

# 使用例
def search_products(**kwargs):
    # 実行前に必ず検証
    validate_input(kwargs)

    query = "SELECT * FROM products WHERE 1=1"
    params = []

    if 'min_sales' in kwargs:
        query += " AND sales_amount >= ?"
        params.append(kwargs['min_sales'])

    # ... 検索実行
```

**なぜ安全か**：
- 想定外の値を事前にブロック
- システムリソースの保護
- 明確なエラーメッセージでユーザーに通知

### 権限管理

#### セキュリティリスク

**リスク1: 機密情報への不正アクセス**
```
悪意のあるユーザー: "全従業員の給与情報を検索して"
→ 権限チェックなしでは、機密データが漏洩
```

**リスク2: 権限昇格**
```
一般ユーザー: "管理者権限が必要な削除処理を実行して"
→ 権限チェックなしでは、不正操作が可能
```

**リスク3: 監査証跡の欠如**
```
誰がいつ何のデータにアクセスしたか不明
→ セキュリティインシデント発生時に原因特定不可
```

#### 対策: 多層防御アプローチ

```python
def search_sensitive_data(user_id, **kwargs):
    """機密データの検索（多層セキュリティ）"""

    # レイヤー1: 認証チェック
    if not is_authenticated(user_id):
        return {
            "status": "error",
            "error_type": "authentication_failed",
            "message": "認証が必要です"
        }

    # レイヤー2: 権限チェック
    if not has_permission(user_id, "read_sensitive_data"):
        # 監査ログに不正アクセス試行を記録
        log_security_event(user_id, "unauthorized_access_attempt", kwargs)

        return {
            "status": "error",
            "error_type": "permission_denied",
            "message": "この操作を実行する権限がありません"
        }

    # レイヤー3: データアクセス制限（行レベルセキュリティ）
    # ユーザーの部門に属するデータのみ取得
    kwargs['department'] = get_user_department(user_id)

    # レイヤー4: 監査ログの記録（成功時）
    log_access(
        user_id=user_id,
        action="search_sensitive_data",
        parameters=kwargs,
        timestamp=datetime.now(),
        ip_address=get_user_ip(user_id)
    )

    # データ取得
    results = execute_search(**kwargs)

    # レイヤー5: データマスキング（追加保護）
    results = mask_sensitive_fields(results, user_id)

    return {
        "status": "success",
        "data": results
    }

def mask_sensitive_fields(results, user_id):
    """ユーザー権限に応じてデータをマスキング"""
    if not has_permission(user_id, "view_full_data"):
        for row in results:
            # 個人情報をマスキング
            if 'phone' in row:
                row['phone'] = row['phone'][:3] + "****" + row['phone'][-4:]
            if 'email' in row:
                row['email'] = row['email'].split('@')[0][:2] + "***@" + row['email'].split('@')[1]

    return results
```

**実装のポイント**：

1. **最小権限の原則**
   - ユーザーに必要最小限の権限のみ付与
   - デフォルトは拒否、明示的な許可のみアクセス可能

2. **監査ログ**
   - 全アクセスを記録（成功・失敗両方）
   - ログに含めるべき情報：
     * ユーザーID
     * アクション
     * パラメータ
     * タイムスタンプ
     * IPアドレス
     * 結果（成功/失敗）

3. **行レベルセキュリティ**
   - ユーザーが所属する組織のデータのみアクセス可能
   - SQLクエリに自動的にフィルタを追加

### レート制限

#### セキュリティリスク

**リスク: DoS攻撃**
```
悪意のあるユーザーが大量のリクエストを送信
→ システムリソースが枯渇し、正常なユーザーがサービスを利用できなくなる
```

#### 対策: レート制限の実装

```python
from functools import wraps
from time import time

def rate_limit(max_calls, time_window):
    """レート制限デコレーター"""
    calls = []

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time()
            # 時間窓外の呼び出しを削除
            calls[:] = [c for c in calls if c > now - time_window]

            if len(calls) >= max_calls:
                return {
                    "status": "error",
                    "error_type": "rate_limit_exceeded",
                    "message": f"{time_window}秒間に{max_calls}回までしか呼び出せません",
                    "retry_after": int(calls[0] + time_window - now)
                }

            calls.append(now)
            return func(*args, **kwargs)
        return wrapper
    return decorator

@rate_limit(max_calls=10, time_window=60)
def search_products(**kwargs):
    # 1分間に10回まで
    return execute_search(**kwargs)
```

## 4.3 パフォーマンス

### トークン使用量の最適化

**description の簡潔化**：

**悪い例**：
```python
"description": "この関数は、データベース内の商品情報を検索するための関数です。様々な条件を指定することができ、売上金額や日付範囲、商品カテゴリなどで絞り込むことが可能です。検索結果は配列形式で返却されます。"
```

**良い例**：
```python
"description": "商品DB検索。売上、日付、カテゴリで絞込可能。"
```

**parameters の最適化**：

```python
# 必要最小限のパラメータのみ定義
"parameters": {
    "type": "object",
    "properties": {
        "query": {
            "type": "string",
            "description": "検索クエリ"
        }
    },
    "required": ["query"]
}
```

### レスポンスタイムの改善

**キャッシュの活用**：

```python
from functools import lru_cache
from datetime import datetime

# 1時間キャッシュ
@lru_cache(maxsize=100)
def get_weather(location, cache_key):
    """天気情報取得（キャッシュ付き）"""
    # 外部APIを呼び出し
    return fetch_weather_from_api(location)

def get_weather_cached(location):
    # 時間ベースのキャッシュキー
    cache_key = datetime.now().replace(minute=0, second=0, microsecond=0)
    return get_weather(location, cache_key)
```

**並列処理**：

```python
import concurrent.futures

def search_multiple_databases(**kwargs):
    """複数DBを並列検索"""
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # 並列実行
        future_db1 = executor.submit(search_db1, **kwargs)
        future_db2 = executor.submit(search_db2, **kwargs)

        # 結果を結合
        results = future_db1.result() + future_db2.result()

    return results
```

**インデックスの活用**：

```sql
-- データベース側の最適化
CREATE INDEX idx_products_date ON products(sale_date);
CREATE INDEX idx_products_category ON products(category);
CREATE INDEX idx_products_sales ON products(sales_amount);
```

### tool_choice の最適化

**状況に応じた使い分け**：

```python
# ユーザーが明確に要求している場合
if "検索して" in user_message or "調べて" in user_message:
    tool_choice = "required"  # 必ず関数を呼び出す
else:
    tool_choice = "auto"  # LLMに判断させる

response = openai.ChatCompletion.create(
    model="gpt-5.1-instant",
    messages=messages,
    tools=tools,
    tool_choice=tool_choice
)
```

**ポイント**：
- 不要な関数呼び出しを避ける
- ユーザー意図を分析して適切に制御
- コスト削減とレスポンス改善

---

## 参考情報

### セキュリティ
- [セキュリティのベストプラクティス - OpenAI公式ドキュメント日本語版](https://openai.itshinan.jp/guides/safety-best-prctices/)
  - OpenAI公式のセキュリティガイド

- [OpenAIのChatGPT APIを利用する際のセキュリティについて - Zenn](https://zenn.dev/deepreneur/articles/9eb5c48368b014)
  - データ保持、DPA、セキュリティ対策

- [Azure OpenAI Service セキュリティベストプラクティス](https://cloud.sojitz-ti.com/blog/azure-open-ai-datasecurity-bestp/)
  - 閉域ネットワーク、プロンプトインジェクション対策

### パフォーマンス
- [Function Calling 最初の一歩 - Qiita](https://qiita.com/wing_man/items/788511a69b09ad3db4e3)
  - 効率的な実装パターン

- [生成AIアプリをより多機能に(Function Calling) - Qiita](https://qiita.com/ksonoda/items/1ba3916c9ee9f4d9c10c)
  - LangChainを使った最適化

### 設計パターン
- [[OpenAI] Function callingで遊んでみたら本質が見えてきた - DevelopersIO](https://dev.classmethod.jp/articles/understand-openai-function-calling/)
  - 設計の本質的な理解
