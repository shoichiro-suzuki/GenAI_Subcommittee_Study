# 5. ベストプラクティス

## 5.1 ツール設計

### 明確な関数名と説明

**悪い例**：
```python
{
    "name": "search",
    "description": "検索する"
}
```

**良い例**：
```python
{
    "name": "search_products_by_criteria",
    "description": "商品データベースを条件で検索する。売上金額、日付範囲、カテゴリなどの条件を指定可能。"
}
```

**ポイント**：
- 関数名は具体的に（`search` → `search_products_by_criteria`）
- 説明文で「何ができるか」を明記
- 利用可能な条件を列挙

### 適切な粒度

**粒度が細かすぎる例**（非推奨）：
```python
tools = [
    {"function": {"name": "get_product_name"}},
    {"function": {"name": "get_product_price"}},
    {"function": {"name": "get_product_stock"}},
]
```

**適切な粒度**（推奨）：
```python
tools = [
    {
        "function": {
            "name": "get_product_info",
            "description": "商品情報を取得する（名前、価格、在庫を含む）"
        }
    }
]
```

**ポイント**：
- 関連する情報は1つの関数にまとめる
- 複数回のAPI呼び出しを避ける
- ただし、責務は明確に分離

### エラーメッセージの設計

**実装例**：
```python
def search_products(**kwargs):
    try:
        # 処理実行
        results = execute_search(**kwargs)
        return {
            "status": "success",
            "data": results,
            "count": len(results)
        }
    except ValueError as e:
        return {
            "status": "error",
            "error_type": "validation_error",
            "message": f"入力値が不正です: {str(e)}",
            "suggestion": "日付はYYYY-MM-DD形式で指定してください"
        }
    except Exception as e:
        return {
            "status": "error",
            "error_type": "system_error",
            "message": f"エラーが発生しました: {str(e)}"
        }
```

**ポイント**：
- 構造化されたエラーレスポンス
- エラータイプを明示
- ユーザーへの改善案を含める

## 5.2 セキュリティ

### 入力検証

**必須の検証項目**：

```python
import re
from datetime import datetime

def validate_input(params):
    """入力パラメータの検証"""

    # 日付形式の検証
    if 'date' in params:
        try:
            datetime.strptime(params['date'], '%Y-%m-%d')
        except ValueError:
            raise ValueError("日付形式が不正です")

    # 数値範囲の検証
    if 'amount' in params:
        if not isinstance(params['amount'], (int, float)):
            raise ValueError("金額は数値で指定してください")
        if params['amount'] < 0:
            raise ValueError("金額は0以上である必要があります")

    # 文字列長の制限
    if 'text' in params:
        if len(params['text']) > 10000:
            raise ValueError("テキストは10000文字以内で指定してください")

    return True
```

### SQLインジェクション対策

**悪い例**（脆弱）：
```python
def search_products(category):
    # 直接SQL文字列を結合 - 危険！
    query = f"SELECT * FROM products WHERE category = '{category}'"
    cursor.execute(query)
```

**良い例**（安全）：
```python
def search_products(category):
    # プレースホルダを使用
    query = "SELECT * FROM products WHERE category = ?"
    cursor.execute(query, (category,))
```

**さらに良い例**（ORM使用）：
```python
from sqlalchemy import select

def search_products(category):
    # ORMを使用して安全にクエリ
    stmt = select(Product).where(Product.category == category)
    results = session.execute(stmt)
```

**ポイント**：
- プレースホルダ（`?` や `%s`）を必ず使用
- ORMの活用を検討
- 入力値のサニタイズ

### 権限管理

**実装例**：
```python
def search_sensitive_data(user_id, **kwargs):
    """機密データの検索（権限チェック付き）"""

    # ユーザー権限の確認
    if not has_permission(user_id, "read_sensitive_data"):
        return {
            "status": "error",
            "error_type": "permission_denied",
            "message": "この操作を実行する権限がありません"
        }

    # 監査ログの記録
    log_access(user_id, "search_sensitive_data", kwargs)

    # データ取得
    return execute_search(**kwargs)
```

**ポイント**：
- 関数実行前に権限チェック
- 監査ログの記録
- 最小権限の原則

### レート制限

```python
from functools import wraps
from time import time

# レート制限のデコレーター
def rate_limit(max_calls, time_window):
    calls = []

    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time()
            # 時間窓外の呼び出しを削除
            calls[:] = [c for c in calls if c > now - time_window]

            if len(calls) >= max_calls:
                return {
                    "status": "error",
                    "error_type": "rate_limit_exceeded",
                    "message": f"{time_window}秒間に{max_calls}回までしか呼び出せません"
                }

            calls.append(now)
            return func(*args, **kwargs)
        return wrapper
    return decorator

@rate_limit(max_calls=10, time_window=60)
def search_products(**kwargs):
    # 1分間に10回まで
    return execute_search(**kwargs)
```

## 5.3 パフォーマンス

### トークン使用量の最適化

**description の簡潔化**：

**悪い例**：
```python
"description": "この関数は、データベース内の商品情報を検索するための関数です。様々な条件を指定することができ、売上金額や日付範囲、商品カテゴリなどで絞り込むことが可能です。検索結果は配列形式で返却されます。"
```

**良い例**：
```python
"description": "商品DB検索。売上、日付、カテゴリで絞込可能。"
```

**parameters の最適化**：

```python
# 必要最小限のパラメータのみ定義
"parameters": {
    "type": "object",
    "properties": {
        "query": {
            "type": "string",
            "description": "検索クエリ"
        }
    },
    "required": ["query"]
}
```

### レスポンスタイムの改善

**キャッシュの活用**：

```python
from functools import lru_cache
from datetime import datetime, timedelta

# 1時間キャッシュ
@lru_cache(maxsize=100)
def get_weather(location, cache_key):
    """天気情報取得（キャッシュ付き）"""
    # 外部APIを呼び出し
    return fetch_weather_from_api(location)

def get_weather_cached(location):
    # 時間ベースのキャッシュキー
    cache_key = datetime.now().replace(minute=0, second=0, microsecond=0)
    return get_weather(location, cache_key)
```

**並列処理**：

```python
import concurrent.futures

def search_multiple_databases(**kwargs):
    """複数DBを並列検索"""
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # 並列実行
        future_db1 = executor.submit(search_db1, **kwargs)
        future_db2 = executor.submit(search_db2, **kwargs)

        # 結果を結合
        results = future_db1.result() + future_db2.result()

    return results
```

**インデックスの活用**：

```sql
-- データベース側の最適化
CREATE INDEX idx_products_date ON products(sale_date);
CREATE INDEX idx_products_category ON products(category);
CREATE INDEX idx_products_sales ON products(sales_amount);
```

### tool_choice の最適化

**状況に応じた使い分け**：

```python
# ユーザーが明確に要求している場合
if "検索して" in user_message or "調べて" in user_message:
    tool_choice = "required"  # 必ず関数を呼び出す
else:
    tool_choice = "auto"  # LLMに判断させる

response = openai.ChatCompletion.create(
    model="gpt-4o",
    messages=messages,
    tools=tools,
    tool_choice=tool_choice
)
```

**ポイント**：
- 不要な関数呼び出しを避ける
- ユーザー意図を分析して適切に制御
- コスト削減とレスポンス改善

---

## 参考情報

### セキュリティ
- [セキュリティのベストプラクティス - OpenAI公式ドキュメント日本語版](https://openai.itshinan.jp/guides/safety-best-prctices/)
  - OpenAI公式のセキュリティガイド

- [OpenAIのChatGPT APIを利用する際のセキュリティについて - Zenn](https://zenn.dev/deepreneur/articles/9eb5c48368b014)
  - データ保持、DPA、セキュリティ対策

- [Azure OpenAI Service セキュリティベストプラクティス](https://cloud.sojitz-ti.com/blog/azure-open-ai-datasecurity-bestp/)
  - 閉域ネットワーク、プロンプトインジェクション対策

### パフォーマンス
- [Function Calling 最初の一歩 - Qiita](https://qiita.com/wing_man/items/788511a69b09ad3db4e3)
  - 効率的な実装パターン

- [生成AIアプリをより多機能に(Function Calling) - Qiita](https://qiita.com/ksonoda/items/1ba3916c9ee9f4d9c10c)
  - LangChainを使った最適化

### 設計パターン
- [[OpenAI] Function callingで遊んでみたら本質が見えてきた - DevelopersIO](https://dev.classmethod.jp/articles/understand-openai-function-calling/)
  - 設計の本質的な理解
